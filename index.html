<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title> Lambda Calculus Evaluator </title>
    <style> code { font-weight: bold; } </style>
</head>
<body style="background-color:#ccc;">
    <center style="margin: 10%;">
        <div style="text-align: left;"> 
            <center> Normal Order λ Calculus Evaluator. </center> <br>
            Variable names can only consist of one letter.
            The expression <code>a b</code> will represent
            the function <code>a</code> applied to <code>b</code>.
            The lambda symbol can be written as 
            <code>\</code> or <code>λ</code>. If you want to declare variables,
             add statements in the beginning and end them with <code>;</code>.
             After the last <code>;</code>, you should put the expression you want
             to evaluate.
        </div> 
        
        <textarea id="code" style="width:80vw;height:100px;" style="width:60vw;" cols="50" rows="5" spellcheck="false"></textarea>
        <input type="button" value="go" onclick="
            D('output').innerHTML = 'ß-reduction in process...'
            setTimeout(_ => (
                D('output').innerHTML = F(D('code').value), 
                D('code').focus()),
                300 + Math.random()*200|0)
        ">
        <div style="margin:10%;">output:</div>
        <div id="output" style="padding:2%;background-color:#444;color:white;"></div>
        <div>
            More info: <br>
            <a href="https://www.inf.fu-berlin.de/lehre/WS03/alpi/lambda.pdf"> lambda pdf 1 </a> <br>
            <a href="http://www.cse.chalmers.se/research/group/logic/TypesSS05/Extra/geuvers.pdf"> lambda pdf 2 </a>
        </div>
    </center>
    <!-- test code should give us 4:
    S = \wyx.y(wyx); P = λn.nG(λz.z00)F; G = (λpz.z(S(pT))(pT)); T = λxy.x; F = λxy.y; 5 = \ab.a(a(a(a(ab)))); 0 =\xy.y; P 5 -->
    <script>
        log=console.log
        const D = x => document.getElementById(x) 
        D('code').value = `1 = λab.ab; 
S = λwyx.y(wyx); 

S 1`
        const history = []
        D('code').focus()
        function F(code) {
            history.length = 0
            V=x=>(log(x),x)
            const sections = V(code.split`;`.map(v => v.split`=`.map(x=>x.trim())))
            let t = sections.pop()[0]
            
            for (let n,v;;) {
                [n,v] = sections.find(([n,v]) => t.includes(n))||[]
                if (n) 
                    t = t.replace(new RegExp(n,"g"),`(${v})`)
                else
                    break
            }
            console.log('t =',t)
            const s = uncurryString(t.replace(/ /g,''))
            return curryString((betaReduce)(s))
        }

        function getTerms(s) {
            return [...s].reduce(([r,x,y],v,i) => {
                const a = v==='(', b = v===')', c = x===1
                if (v==='λ' && x === 0 && !y) { r.push(''); y=1 }
                if (y) { r[r.length-1] += v; return [r,x,y] }
                if (x > 0) { 
                    if (!(b&&c)) r[r.length-1] += v
                    return [r, x + (({')':-1,'(':1})[v]||0)] 
                }
                if (a) return [[...r,''],x+1]
                return [[...r,v],x]
            },[[],0,0])[0]
        }
        function curryString(s) {
            return s.replace(/\.λ/g,'')
        }

        function uncurryString(s) {
            return [...s.replace(/(λ|\\)(\w+)\./g,"[$2]")].reduce(([s,x],v,i) =>
                '[]'.includes(v) ? [s,x^=1] : [s+(x?'λ'+v+'.':v),x]
            ,['',0])[0]
        }

        function betaReduce(s) {
            // check if infinite loop:
            const i = history.lastIndexOf(s), l = history.length
            if (i >= 0) {
                // if (l > 1 && history.slice(0,i).join`:`.endsWith(history.slice(i).join`:`)) {
                if (l > 1000) {
                    // log('history =',history)
                    return history.slice(0,15).join`<br>` + '<br>...<br>[ divergent expression ]'
                }
            }
            history.push(s)
            log('s =',s)

            const terms = getTerms(s)
            let [a,b] = terms
            if (a == null) return;

            if (b == null) {
                return s.length === 1 ? s : 
                        s[0] === '(' ? betaReduce(s.slice(1,-1)) :
                        s[0] === 'λ' ? s.slice(0,3) + betaReduce(s.slice(3)) :
                        ('(' + terms.map(betaReduce).join`)(` + ')').replace(/\((.)\)/g,'$1')
            }


            if (a[0] !== 'λ') { // first term isn't a lambda
                if (a[0] === '(') terms[0] = betaReduce(a)
                return (terms[0] === a ? _=>_ : betaReduce)
                    (('(' + terms.map(betaReduce).join`)(` + ')').replace(/\((.)\)/g,'$1'))
            }

            if (!s.includes('(')) { // cannot reduce without parenthesis
                return s 
            }

            const [avars,bvars] = [a,b].map(s=>Array.from(new Set(s.replace(/[^a-zA-Z]/g,''))))
            const allvars = [...avars,...bvars]
            const [aboundvars,bboundvars] = [avars,bvars]
                .map((x,i)=>x.filter(v => [a,b][i].includes('λ'+v)))
            
            const freeavars = avars.filter(v => !aboundvars.includes(v))
            const alpha = [...'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ']

            // renaming of variables in an expression a b:
            //   we only rename bound variables.
            //   we only rename variables in a if:
            //     they are the same as any in b
            //   we only rename variables in b if:
            //     they are the same as any free variables in a 

            aboundvars.forEach((v,i) => { // rename a's bound variables if found in bvars
                if (bvars.includes(v)) {
                    for (const c of alpha) {
                        if (!allvars.includes(c)) {
                            allvars.push(c)
                            a = terms[0] = a.replace(new RegExp(v,"g"),c)
                            return;
                        }
                    }
                    throw "can't rename more variables"
                }
            })

            bboundvars.forEach((v,i) => { // rename b's bound variables if found in freeavars
                if (freeavars.includes(v)) {
                    for (const c of alpha) {
                        if (!allvars.includes(c)) {
                            allvars.push(c)
                            b = terms[1] = b.replace(new RegExp(v,"g"),c)
                            return;
                        }
                    }
                    throw "can't rename more variables"
                }
            })
            const nextFree = alpha.find(c => !allvars.includes(c))
            // rename any inner bounded variables in a
            const A = [...a.slice(3)].reduce(([s,x],v,i) => {
                if (a.slice(3+i).startsWith('λ'+a[1])) x = 1
                if (x > 0) x += v === '(' ? 1 : v === ')' ? -1 : 0
                if (v === a[1] && x > 0) v = nextFree
                return [v === a[1] && x === 0 ? s + `(${b})` : s + v, x]
            }, ['',0])[0]

            const applied = A.replace(new RegExp(a[1],"g"),`(${b})`)
            log('applied =',applied)
            const t = terms.length > 2 ? '(' + applied + ')' +
                (('(' + terms.slice(2).map(betaReduce).join`)(` + ')').replace(/\((.)\)/g,'$1')) : applied
                
            return betaReduce(t)
        }

    </script>
    <script src="tests.js"></script>
</body>
</html>